"use strict";
/*
 * Copyright 2020 - MATTR Limited
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Inject the RNG source when in NodeJS environments
const { randomBytes } = require("@stablelib/random");

// This ends up pointing to a CJS version of the ES module generated by wasm-pack
// which is done post-compile via rollup
const wasm = require("./wasm.js");
const {
  generateSignatureParamsG1,
  generateBBSBls12381G1KeyPair,
  bbsSignG1, bbsVerfiyG1, bbsCommitMsgsInG1, bbsBlindSignG1, bbsUnblindSigG1, bbsInitializeProofOfKnowledgeOfSignature,
  bbsVerifyProofOfKnowledgeOfSignature, isSignatureParamsG1Valid, bbsSignatureParamsG1MaxSupportedMsgs,
  isBBSPublicKeyG1Valid,
} = require("./index");

// TODO should be able to remove this duplicate definition syntax by using ESM over index.web.js
// in future

module.exports.DEFAULT_BLS12381_PRIVATE_KEY_LENGTH = 32;

module.exports.DEFAULT_BLS12381_G1_PUBLIC_KEY_LENGTH = 48;

module.exports.DEFAULT_BLS12381_G2_PUBLIC_KEY_LENGTH = 96;

module.exports.BBS_SIGNATURE_LENGTH = 112;

// Casts a rejected promise to an error rather than a
// simple string result
const throwErrorOnRejectedPromise = async (promise, errorMessage) => {
  try {
    return await promise;
  } catch (ex) {
    if (errorMessage) {
      throw new Error(errorMessage);
    }
    throw new Error(ex);
  }
};

let initializedModule;
const initialize = async () => {
  if (!initializedModule) {
    initializedModule = await wasm.default();
  }
};

module.exports.generateBls12381G1KeyPair = async (seed) => {
  await initialize();
  var result = await throwErrorOnRejectedPromise(
    wasm.generateBls12381G1KeyPair(seed ? seed : await randomBytes(32))
  );
  return {
    secretKey: new Uint8Array(result.secretKey),
    publicKey: new Uint8Array(result.publicKey),
  };
};

module.exports.generateBls12381G2KeyPair = async (seed) => {
  await initialize();
  var result = await throwErrorOnRejectedPromise(
    wasm.generateBls12381G2KeyPair(seed ? seed : await randomBytes(32))
  );
  return {
    secretKey: new Uint8Array(result.secretKey),
    publicKey: new Uint8Array(result.publicKey),
  };
};

module.exports.bls12381toBbs = async (request) => {
  await initialize();
  var result = await throwErrorOnRejectedPromise(wasm.bls12381toBbs(request));
  return {
    publicKey: new Uint8Array(result.publicKey),
    secretKey: result.secretKey ? new Uint8Array(result.secretKey) : undefined,
    messageCount: result.messageCount,
  };
};

module.exports.sign = async (request) => {
  await initialize();
  return await throwErrorOnRejectedPromise(wasm.sign(request));
};

module.exports.blsSign = async (request) => {
  await initialize();
  return await throwErrorOnRejectedPromise(wasm.blsSign(request));
};

module.exports.verify = async (request) => {
  await initialize();
  return await throwErrorOnRejectedPromise(wasm.verify(request));
};

module.exports.blsVerify = async (request) => {
  await initialize();
  return await throwErrorOnRejectedPromise(wasm.blsVerify(request));
};

module.exports.createProof = async (request) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
    wasm.createProof(request),
    "Failed to create proof"
  );
};

module.exports.blsCreateProof = async (request) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
    wasm.blsCreateProof(request),
    "Failed to create proof"
  );
};

module.exports.verifyProof = async (request) => {
  await initialize();
  return await throwErrorOnRejectedPromise(wasm.verifyProof(request));
};

module.exports.blsVerifyProof = async (request) => {
  await initialize();
  return await throwErrorOnRejectedPromise(wasm.blsVerifyProof(request));
};

module.exports.generateRandomFieldElement = async (seed) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
    wasm.generateRandomFieldElement(seed)
  );
};

module.exports.generateBBSSigningKey = async (seed) => {
  await initialize();
  return await throwErrorOnRejectedPromise(wasm.generateBBSSigningKey(seed));
};

module.exports.generateSignatureParamsG1 = async (messageCount, label) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
    wasm.generateSignatureParamsG1(messageCount, label)
  );
};

module.exports.isSignatureParamsG1Valid = async (params) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
      wasm.isSignatureParamsG1Valid(params)
  );
};

module.exports.bbsSignatureParamsG1MaxSupportedMsgs = async (params) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
      wasm.bbsSignatureParamsG1MaxSupportedMsgs(params)
  );
};

module.exports.generateSignatureParamsG2 = async (messageCount, label) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
    wasm.generateSignatureParamsG2(messageCount, label)
  );
};

module.exports.isSignatureParamsG2Valid = async (params) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
      wasm.isSignatureParamsG2Valid(params)
  );
};

module.exports.bbsSignatureParamsG2MaxSupportedMsgs = async (params) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
      wasm.bbsSignatureParamsG2MaxSupportedMsgs(params)
  );
};

module.exports.generateBBSPublicKeyG1 = async (secretKey, params) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
    wasm.generateBBSPublicKeyG1(secretKey, params)
  );
};

module.exports.isBBSPublicKeyG1Valid = async (publicKey) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
      wasm.isBBSPublicKeyG1Valid(publicKey)
  );
};

module.exports.generateBBSPublicKeyG2 = async (secretKey, params) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
    wasm.generateBBSPublicKeyG2(secretKey, params)
  );
};

module.exports.isBBSPublicKeyG2Valid = async (publicKey) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
      wasm.isBBSPublicKeyG2Valid(publicKey)
  );
};

module.exports.generateBBSKeyPairG1 = async (params, seed) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
    wasm.generateBBSKeyPairG1(params, seed)
  );
};

module.exports.generateBBSKeyPairG2 = async (params, seed) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
    wasm.generateBBSKeyPairG2(params, seed)
  );
};

module.exports.bbsSignG1 = async (
  messages,
  secretKey,
  params,
  encodeMessages
) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
    wasm.bbsSignG1(messages, secretKey, params, encodeMessages)
  );
};

module.exports.bbsSignG2 = async (
  messages,
  secretKey,
  params,
  encodeMessages
) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
    wasm.bbsSignG2(messages, secretKey, params, encodeMessages)
  );
};

module.exports.bbsVerfiyG1 = async (
    messages,
    signature,
    publicKey,
    params,
    encodeMessages
) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
      wasm.bbsVerfiyG1(messages, signature, publicKey, params, encodeMessages)
  );
};

module.exports.bbsVerfiyG2 = async (
    messages,
    signature,
    publicKey,
    params,
    encodeMessages
) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
      wasm.bbsVerfiyG2(messages, signature, publicKey, params, encodeMessages)
  );
};

module.exports.bbsCommitMsgsInG1 = async (
    messages,
    blinding,
    params,
    encodeMessages
) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
      wasm.bbsCommitMsgsInG1(messages, blinding, params, encodeMessages)
  );
};

module.exports.bbsCommitMsgsInG2 = async (
    messages,
    blinding,
    params,
    encodeMessages
) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
      wasm.bbsCommitMsgsInG2(messages, blinding, params, encodeMessages)
  );
};

module.exports.bbsBlindSignG1 = async (
    commitment,
    uncommittedMessages,
    secretKey,
    params,
    encodeMessages
) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
      wasm.bbsBlindSignG1(commitment, uncommittedMessages, blinding, params, encodeMessages)
  );
};

module.exports.bbsBlindSignG2 = async (
    commitment,
    uncommittedMessages,
    secretKey,
    params,
    encodeMessages
) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
      wasm.bbsBlindSignG2(commitment, uncommittedMessages, blinding, params, encodeMessages)
  );
};

module.exports.bbsUnblindSigG1 = async (
    signature,
    blinding,
) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
      wasm.bbsUnblindSigG1(signature, blinding)
  );
};

module.exports.bbsUnblindSigG2 = async (
    signature,
    blinding,
) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
      wasm.bbsUnblindSigG2(signature, blinding)
  );
};

module.exports.bbsInitializeProofOfKnowledgeOfSignature = async (
    signature,
    params,
    messages,
    blindings,
    revealedIndices,
    encodeMessages
) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
      wasm.bbsInitializeProofOfKnowledgeOfSignature(signature, params, messages, blindings, revealedIndices, encodeMessages)
  );
};

module.exports.bbsVerifyProofOfKnowledgeOfSignature = async (
    proof,
    revealedMessages,
    challenge,
    publicKey,
    params,
    encodeMessages
) => {
  await initialize();
  return await throwErrorOnRejectedPromise(
      wasm.bbsVerifyProofOfKnowledgeOfSignature(proof, revealedMessages, challenge, publicKey, params, encodeMessages)
  );
};