use crate::utils::{fr_from_uint8_array, g1_affine_from_uint8_array, g2_affine_from_uint8_array, js_array_to_g1_affine_vec, js_array_to_g2_affine_vec, set_panic_hook};
use ark_bls12_381::Bls12_381;
use ark_ec::pairing::Pairing;
use js_sys::Uint8Array;
use proof_system::{
    meta_statement::{EqualWitnesses, MetaStatement},
    prelude,
};
use crate::G1Affine;
use std::collections::BTreeSet;
use wasm_bindgen::{prelude::wasm_bindgen, JsValue};
use zeroize::Zeroize;

// All `Statement`s are returned in their uncompressed form as they are generated by the same party using
// them unlike signature params, public keys, proofs, etc

pub(crate) type PedCommG1Stmt =
    prelude::ped_comm::PedersenCommitment<<Bls12_381 as Pairing>::G1Affine>;
pub(crate) type PedCommG2Stmt =
    prelude::ped_comm::PedersenCommitment<<Bls12_381 as Pairing>::G2Affine>;

pub(crate) type InequalityG1Stmt = prelude::inequality::PublicInequality<<Bls12_381 as Pairing>::G1Affine>;

#[wasm_bindgen(js_name = generatePedersenCommitmentG1Statement)]
pub fn generate_pedersen_commitment_g1_statement(
    commitment_key: js_sys::Array,
    commitment: Uint8Array,
) -> Result<Uint8Array, JsValue> {
    set_panic_hook();
    let commitment_key = js_array_to_g1_affine_vec(&commitment_key)?;
    let commitment = g1_affine_from_uint8_array(commitment)?;
    let statement =
        PedCommG1Stmt::new_statement_from_params::<Bls12_381>(commitment_key, commitment);
    Ok(obj_to_uint8array_uncompressed!(&statement, "PedCommG1Stmt"))
}

#[wasm_bindgen(js_name = generatePedersenCommitmentG1StatementFromParamRefs)]
pub fn generate_pedersen_commitment_g1_statement_from_param_refs(
    commitment_key: usize,
    commitment: Uint8Array,
) -> Result<Uint8Array, JsValue> {
    set_panic_hook();
    let commitment = g1_affine_from_uint8_array(commitment)?;
    let statement =
        PedCommG1Stmt::new_statement_from_params_refs::<Bls12_381>(commitment_key, commitment);
    Ok(obj_to_uint8array_uncompressed!(&statement, "PedCommG1Stmt"))
}

#[wasm_bindgen(js_name = generatePedersenCommitmentG2Statement)]
pub fn generate_pedersen_commitment_g2_statement(
    commitment_key: js_sys::Array,
    commitment: Uint8Array,
) -> Result<Uint8Array, JsValue> {
    set_panic_hook();
    let commitment_key = js_array_to_g2_affine_vec(&commitment_key)?;
    let commitment = g2_affine_from_uint8_array(commitment)?;
    let statement =
        PedCommG2Stmt::new_statement_from_params::<Bls12_381>(commitment_key, commitment);
    Ok(obj_to_uint8array_uncompressed!(&statement, "PedCommG2Stmt"))
}

#[wasm_bindgen(js_name = generatePedersenCommitmentG2StatementFromParamRefs)]
pub fn generate_pedersen_commitment_g2_statement_from_param_refs(
    commitment_key: usize,
    commitment: Uint8Array,
) -> Result<Uint8Array, JsValue> {
    set_panic_hook();
    let commitment = g2_affine_from_uint8_array(commitment)?;
    let statement =
        PedCommG2Stmt::new_statement_from_params_refs::<Bls12_381>(commitment_key, commitment);
    Ok(obj_to_uint8array_uncompressed!(&statement, "PedCommG2Stmt"))
}

#[wasm_bindgen(js_name = generatePublicInequalityG1Statement)]
pub fn generate_public_inequality_g1_statement(
    inequal_to: Uint8Array,
    commitment_key: Uint8Array,
    uncompressed_key: bool,
) -> Result<Uint8Array, JsValue> {
    set_panic_hook();
    let commitment_key = if uncompressed_key {
        obj_from_uint8array_uncompressed!(schnorr_pok::inequality::CommitmentKey<G1Affine>, commitment_key, "CommitmentKey")
    } else {
        obj_from_uint8array!(schnorr_pok::inequality::CommitmentKey<G1Affine>, commitment_key, false, "CommitmentKey")
    };
    let inequal_to = fr_from_uint8_array(inequal_to, false)?;
    let statement =
        InequalityG1Stmt::new_statement_from_params::<Bls12_381>(inequal_to, commitment_key);
    Ok(obj_to_uint8array_uncompressed!(&statement, "InequalityG1Stmt"))
}

#[wasm_bindgen(js_name = generatePublicInequalityG1StatementFromParamRefs)]
pub fn generate_public_inequality_g1_statement_from_param_refs(
    inequal_to: Uint8Array,
    commitment_key: usize,
) -> Result<Uint8Array, JsValue> {
    set_panic_hook();
    let inequal_to = fr_from_uint8_array(inequal_to, false)?;
    let statement =
        InequalityG1Stmt::new_statement_from_params_ref::<Bls12_381>(inequal_to, commitment_key);
    Ok(obj_to_uint8array_uncompressed!(&statement, "InequalityG1Stmt"))
}

#[wasm_bindgen(js_name = generateWitnessEqualityMetaStatement)]
pub fn generate_witness_equality_meta_statement(equality: js_sys::Set) -> Result<JsValue, JsValue> {
    set_panic_hook();
    let mut set = BTreeSet::new();
    for wr in equality.values() {
        let wr = wr.unwrap();
        let arr_2 = js_sys::Array::from(&wr);
        if arr_2.length() != 2 {
            return Err(JsValue::from("Each equality should be a 2 element array"));
        }
        let i: u32 = serde_wasm_bindgen::from_value(arr_2.get(0)).unwrap();
        let j: u32 = serde_wasm_bindgen::from_value(arr_2.get(1)).unwrap();
        set.insert((i as usize, j as usize));
    }
    serde_wasm_bindgen::to_value(&MetaStatement::WitnessEquality(EqualWitnesses(set)))
        .map_err(JsValue::from)
}

pub mod pok_sig;
pub use pok_sig::*;
pub mod accumulator;
pub use accumulator::*;
pub mod saver;
pub use saver::*;
pub mod bound_check;
pub use bound_check::*;
pub mod r1cs;
pub use r1cs::*;
